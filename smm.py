#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed May  3 10:52:22 2017 by generateDS.py version 2.25a.
#
# Command line options:
#   ('-o', 'smm.py')
#   ('-s', 'smm_subclasses.py')
#   ('--super', 'smm_api')
#
# Command line arguments:
#   smm.xsd
#
# Command line:
#   /usr/bin/generateDS.py -o "smm.py" -s "smm_subclasses.py" --super="smm_api" smm.xsd
#
# Current working directory (os.getcwd()):
#   smmlinux
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name, pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0, optional=0):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class SMMTrainInput(GeneratedsSuper):
    """Contains the parameters and training information needed to start the
    SMM program"""
    subclass = None
    superclass = None
    def __init__(self, OutputFile=None, TrainingData=None, MatrixCalculation=None, PairCalculation=None):
        self.original_tagname_ = None
        self.OutputFile = OutputFile
        self.TrainingData = TrainingData
        self.MatrixCalculation = MatrixCalculation
        self.PairCalculation = PairCalculation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SMMTrainInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SMMTrainInput.subclass:
            return SMMTrainInput.subclass(*args_, **kwargs_)
        else:
            return SMMTrainInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OutputFile(self): return self.OutputFile
    def set_OutputFile(self, OutputFile): self.OutputFile = OutputFile
    def get_TrainingData(self): return self.TrainingData
    def set_TrainingData(self, TrainingData): self.TrainingData = TrainingData
    def get_MatrixCalculation(self): return self.MatrixCalculation
    def set_MatrixCalculation(self, MatrixCalculation): self.MatrixCalculation = MatrixCalculation
    def get_PairCalculation(self): return self.PairCalculation
    def set_PairCalculation(self, PairCalculation): self.PairCalculation = PairCalculation
    def hasContent_(self):
        if (
            self.OutputFile is not None or
            self.TrainingData is not None or
            self.MatrixCalculation is not None or
            self.PairCalculation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SMMTrainInput', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SMMTrainInput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SMMTrainInput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SMMTrainInput'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SMMTrainInput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OutputFile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOutputFile>%s</%sOutputFile>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OutputFile), input_name='OutputFile')), namespace_, eol_))
        if self.TrainingData is not None:
            self.TrainingData.export(outfile, level, namespace_, name_='TrainingData', pretty_print=pretty_print)
        if self.MatrixCalculation is not None:
            self.MatrixCalculation.export(outfile, level, namespace_, name_='MatrixCalculation', pretty_print=pretty_print)
        if self.PairCalculation is not None:
            self.PairCalculation.export(outfile, level, namespace_, name_='PairCalculation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OutputFile':
            OutputFile_ = child_.text
            OutputFile_ = self.gds_validate_string(OutputFile_, node, 'OutputFile')
            self.OutputFile = OutputFile_
        elif nodeName_ == 'TrainingData':
            obj_ = TrainingDataType.factory()
            obj_.build(child_)
            self.TrainingData = obj_
            obj_.original_tagname_ = 'TrainingData'
        elif nodeName_ == 'MatrixCalculation':
            obj_ = MatrixCalculationType.factory()
            obj_.build(child_)
            self.MatrixCalculation = obj_
            obj_.original_tagname_ = 'MatrixCalculation'
        elif nodeName_ == 'PairCalculation':
            obj_ = PairCalculationType.factory()
            obj_.build(child_)
            self.PairCalculation = obj_
            obj_.original_tagname_ = 'PairCalculation'
# end class SMMTrainInput


class SMMTrainOutput(GeneratedsSuper):
    """Contains the output generated by the SMM program. Output can be used
    to predict "measurement" values for sequences."""
    subclass = None
    superclass = None
    def __init__(self, Log=None, SMMPredictor=None):
        self.original_tagname_ = None
        self.Log = Log
        self.SMMPredictor = SMMPredictor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SMMTrainOutput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SMMTrainOutput.subclass:
            return SMMTrainOutput.subclass(*args_, **kwargs_)
        else:
            return SMMTrainOutput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Log(self): return self.Log
    def set_Log(self, Log): self.Log = Log
    def get_SMMPredictor(self): return self.SMMPredictor
    def set_SMMPredictor(self, SMMPredictor): self.SMMPredictor = SMMPredictor
    def hasContent_(self):
        if (
            self.Log is not None or
            self.SMMPredictor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SMMTrainOutput', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SMMTrainOutput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SMMTrainOutput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SMMTrainOutput'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SMMTrainOutput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Log is not None:
            self.Log.export(outfile, level, namespace_, name_='Log', pretty_print=pretty_print)
        if self.SMMPredictor is not None:
            self.SMMPredictor.export(outfile, level, namespace_, name_='SMMPredictor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Log':
            obj_ = Log.factory()
            obj_.build(child_)
            self.Log = obj_
            obj_.original_tagname_ = 'Log'
        elif nodeName_ == 'SMMPredictor':
            obj_ = SMMPredictor.factory()
            obj_.build(child_)
            self.SMMPredictor = obj_
            obj_.original_tagname_ = 'SMMPredictor'
# end class SMMTrainOutput


class SMMParameters(GeneratedsSuper):
    """Parameters used by the core SMM algorithm"""
    subclass = None
    superclass = None
    def __init__(self, Repeats=None, LambdaRange=None, Precission=None, SeedRandomizer=None, MaxNormIterations=None):
        self.original_tagname_ = None
        self.Repeats = Repeats
        self.LambdaRange = LambdaRange
        self.Precission = Precission
        self.validate_PrecissionType(self.Precission)
        self.SeedRandomizer = SeedRandomizer
        self.MaxNormIterations = MaxNormIterations
        self.validate_MaxNormIterationsType(self.MaxNormIterations)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SMMParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SMMParameters.subclass:
            return SMMParameters.subclass(*args_, **kwargs_)
        else:
            return SMMParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Repeats(self): return self.Repeats
    def set_Repeats(self, Repeats): self.Repeats = Repeats
    def get_LambdaRange(self): return self.LambdaRange
    def set_LambdaRange(self, LambdaRange): self.LambdaRange = LambdaRange
    def get_Precission(self): return self.Precission
    def set_Precission(self, Precission): self.Precission = Precission
    def get_SeedRandomizer(self): return self.SeedRandomizer
    def set_SeedRandomizer(self, SeedRandomizer): self.SeedRandomizer = SeedRandomizer
    def get_MaxNormIterations(self): return self.MaxNormIterations
    def set_MaxNormIterations(self, MaxNormIterations): self.MaxNormIterations = MaxNormIterations
    def validate_PrecissionType(self, value):
        # Validate type PrecissionType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PrecissionType' % {"value" : value} )
    def validate_MaxNormIterationsType(self, value):
        # Validate type MaxNormIterationsType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on MaxNormIterationsType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Repeats is not None or
            self.LambdaRange is not None or
            self.Precission is not None or
            self.SeedRandomizer is not None or
            self.MaxNormIterations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SMMParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SMMParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SMMParameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SMMParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SMMParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Repeats is not None:
            self.Repeats.export(outfile, level, namespace_, name_='Repeats', pretty_print=pretty_print)
        if self.LambdaRange is not None:
            self.LambdaRange.export(outfile, level, namespace_, name_='LambdaRange', pretty_print=pretty_print)
        if self.Precission is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrecission>%s</%sPrecission>%s' % (namespace_, self.gds_format_double(self.Precission, input_name='Precission'), namespace_, eol_))
        if self.SeedRandomizer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeedRandomizer>%s</%sSeedRandomizer>%s' % (namespace_, self.gds_format_integer(self.SeedRandomizer, input_name='SeedRandomizer'), namespace_, eol_))
        if self.MaxNormIterations is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxNormIterations>%s</%sMaxNormIterations>%s' % (namespace_, self.gds_format_integer(self.MaxNormIterations, input_name='MaxNormIterations'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Repeats':
            obj_ = RepeatsType.factory()
            obj_.build(child_)
            self.Repeats = obj_
            obj_.original_tagname_ = 'Repeats'
        elif nodeName_ == 'LambdaRange':
            obj_ = LambdaRangeType.factory()
            obj_.build(child_)
            self.LambdaRange = obj_
            obj_.original_tagname_ = 'LambdaRange'
        elif nodeName_ == 'Precission':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Precission')
            self.Precission = fval_
            # validate type PrecissionType
            self.validate_PrecissionType(self.Precission)
        elif nodeName_ == 'SeedRandomizer':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SeedRandomizer')
            self.SeedRandomizer = ival_
        elif nodeName_ == 'MaxNormIterations':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MaxNormIterations')
            self.MaxNormIterations = ival_
            # validate type MaxNormIterationsType
            self.validate_MaxNormIterationsType(self.MaxNormIterations)
# end class SMMParameters


class SMMPredictor(GeneratedsSuper):
    """Contains the data needed to make predictions for any sequence
    specified by Alphabet and SequenceLength"""
    subclass = None
    superclass = None
    def __init__(self, Alphabet=None, SequenceLength=None, SeqMatrix=None, SeqPair=None):
        self.original_tagname_ = None
        self.Alphabet = Alphabet
        self.SequenceLength = SequenceLength
        self.SeqMatrix = SeqMatrix
        self.SeqPair = SeqPair
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SMMPredictor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SMMPredictor.subclass:
            return SMMPredictor.subclass(*args_, **kwargs_)
        else:
            return SMMPredictor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Alphabet(self): return self.Alphabet
    def set_Alphabet(self, Alphabet): self.Alphabet = Alphabet
    def get_SequenceLength(self): return self.SequenceLength
    def set_SequenceLength(self, SequenceLength): self.SequenceLength = SequenceLength
    def get_SeqMatrix(self): return self.SeqMatrix
    def set_SeqMatrix(self, SeqMatrix): self.SeqMatrix = SeqMatrix
    def get_SeqPair(self): return self.SeqPair
    def set_SeqPair(self, SeqPair): self.SeqPair = SeqPair
    def hasContent_(self):
        if (
            self.Alphabet is not None or
            self.SequenceLength is not None or
            self.SeqMatrix is not None or
            self.SeqPair is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SMMPredictor', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SMMPredictor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SMMPredictor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SMMPredictor'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SMMPredictor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Alphabet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAlphabet>%s</%sAlphabet>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Alphabet), input_name='Alphabet')), namespace_, eol_))
        if self.SequenceLength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSequenceLength>%s</%sSequenceLength>%s' % (namespace_, self.gds_format_integer(self.SequenceLength, input_name='SequenceLength'), namespace_, eol_))
        if self.SeqMatrix is not None:
            self.SeqMatrix.export(outfile, level, namespace_, name_='SeqMatrix', pretty_print=pretty_print)
        if self.SeqPair is not None:
            self.SeqPair.export(outfile, level, namespace_, name_='SeqPair', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Alphabet':
            Alphabet_ = child_.text
            Alphabet_ = self.gds_validate_string(Alphabet_, node, 'Alphabet')
            self.Alphabet = Alphabet_
        elif nodeName_ == 'SequenceLength':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SequenceLength')
            self.SequenceLength = ival_
        elif nodeName_ == 'SeqMatrix':
            obj_ = SeqMatrix.factory()
            obj_.build(child_)
            self.SeqMatrix = obj_
            obj_.original_tagname_ = 'SeqMatrix'
        elif nodeName_ == 'SeqPair':
            obj_ = SeqPairType.factory()
            obj_.build(child_)
            self.SeqPair = obj_
            obj_.original_tagname_ = 'SeqPair'
# end class SMMPredictor


class SMMPredictInput(GeneratedsSuper):
    """Contains Sequences for which predictions will be made with
    SMMPredictor, as generated in SMMTrainOutput"""
    subclass = None
    superclass = None
    def __init__(self, OutputFile=None, SMMPredictor=None, Predict=None):
        self.original_tagname_ = None
        self.OutputFile = OutputFile
        self.SMMPredictor = SMMPredictor
        if Predict is None:
            self.Predict = []
        else:
            self.Predict = Predict
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SMMPredictInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SMMPredictInput.subclass:
            return SMMPredictInput.subclass(*args_, **kwargs_)
        else:
            return SMMPredictInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OutputFile(self): return self.OutputFile
    def set_OutputFile(self, OutputFile): self.OutputFile = OutputFile
    def get_SMMPredictor(self): return self.SMMPredictor
    def set_SMMPredictor(self, SMMPredictor): self.SMMPredictor = SMMPredictor
    def get_Predict(self): return self.Predict
    def set_Predict(self, Predict): self.Predict = Predict
    def add_Predict(self, value): self.Predict.append(value)
    def insert_Predict_at(self, index, value): self.Predict.insert(index, value)
    def replace_Predict_at(self, index, value): self.Predict[index] = value
    def hasContent_(self):
        if (
            self.OutputFile is not None or
            self.SMMPredictor is not None or
            self.Predict
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SMMPredictInput', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SMMPredictInput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SMMPredictInput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SMMPredictInput'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SMMPredictInput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OutputFile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOutputFile>%s</%sOutputFile>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.OutputFile), input_name='OutputFile')), namespace_, eol_))
        if self.SMMPredictor is not None:
            self.SMMPredictor.export(outfile, level, namespace_, name_='SMMPredictor', pretty_print=pretty_print)
        for Predict_ in self.Predict:
            Predict_.export(outfile, level, namespace_, name_='Predict', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OutputFile':
            OutputFile_ = child_.text
            OutputFile_ = self.gds_validate_string(OutputFile_, node, 'OutputFile')
            self.OutputFile = OutputFile_
        elif nodeName_ == 'SMMPredictor':
            obj_ = SMMPredictor.factory()
            obj_.build(child_)
            self.SMMPredictor = obj_
            obj_.original_tagname_ = 'SMMPredictor'
        elif nodeName_ == 'Predict':
            obj_ = PredictType.factory()
            obj_.build(child_)
            self.Predict.append(obj_)
            obj_.original_tagname_ = 'Predict'
# end class SMMPredictInput


class SMMPredictOutput(GeneratedsSuper):
    """Contains Sequences with their associated predictions"""
    subclass = None
    superclass = None
    def __init__(self, Log=None, Predict=None):
        self.original_tagname_ = None
        self.Log = Log
        if Predict is None:
            self.Predict = []
        else:
            self.Predict = Predict
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SMMPredictOutput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SMMPredictOutput.subclass:
            return SMMPredictOutput.subclass(*args_, **kwargs_)
        else:
            return SMMPredictOutput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Log(self): return self.Log
    def set_Log(self, Log): self.Log = Log
    def get_Predict(self): return self.Predict
    def set_Predict(self, Predict): self.Predict = Predict
    def add_Predict(self, value): self.Predict.append(value)
    def insert_Predict_at(self, index, value): self.Predict.insert(index, value)
    def replace_Predict_at(self, index, value): self.Predict[index] = value
    def hasContent_(self):
        if (
            self.Log is not None or
            self.Predict
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SMMPredictOutput', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SMMPredictOutput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SMMPredictOutput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SMMPredictOutput'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SMMPredictOutput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Log is not None:
            self.Log.export(outfile, level, namespace_, name_='Log', pretty_print=pretty_print)
        for Predict_ in self.Predict:
            Predict_.export(outfile, level, namespace_, name_='Predict', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Log':
            obj_ = Log.factory()
            obj_.build(child_)
            self.Log = obj_
            obj_.original_tagname_ = 'Log'
        elif nodeName_ == 'Predict':
            obj_ = PredictType1.factory()
            obj_.build(child_)
            self.Predict.append(obj_)
            obj_.original_tagname_ = 'Predict'
# end class SMMPredictOutput


class SeqMatrix(GeneratedsSuper):
    """Measures the influence of each Letter of the Alphabet at each
    position in Sequence."""
    subclass = None
    superclass = None
    def __init__(self, Offset=None, MatCoef=None):
        self.original_tagname_ = None
        self.Offset = Offset
        if MatCoef is None:
            self.MatCoef = []
        else:
            self.MatCoef = MatCoef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SeqMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SeqMatrix.subclass:
            return SeqMatrix.subclass(*args_, **kwargs_)
        else:
            return SeqMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def get_MatCoef(self): return self.MatCoef
    def set_MatCoef(self, MatCoef): self.MatCoef = MatCoef
    def add_MatCoef(self, value): self.MatCoef.append(value)
    def insert_MatCoef_at(self, index, value): self.MatCoef.insert(index, value)
    def replace_MatCoef_at(self, index, value): self.MatCoef[index] = value
    def hasContent_(self):
        if (
            self.Offset is not None or
            self.MatCoef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SeqMatrix', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SeqMatrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SeqMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SeqMatrix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SeqMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Offset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOffset>%s</%sOffset>%s' % (namespace_, self.gds_format_double(self.Offset, input_name='Offset'), namespace_, eol_))
        for MatCoef_ in self.MatCoef:
            MatCoef_.export(outfile, level, namespace_, name_='MatCoef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Offset':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Offset')
            self.Offset = fval_
        elif nodeName_ == 'MatCoef':
            obj_ = MatCoefType.factory()
            obj_.build(child_)
            self.MatCoef.append(obj_)
            obj_.original_tagname_ = 'MatCoef'
# end class SeqMatrix


class Log(GeneratedsSuper):
    """If success=false, ErrorMessage will contain a string describing the
    Error, and LogText will contain any output generated during
    calculation. The content of all other elements is not defined."""
    subclass = None
    superclass = None
    def __init__(self, success=None, LogText=None, ErrorMessage=None):
        self.original_tagname_ = None
        self.success = _cast(bool, success)
        self.LogText = LogText
        self.ErrorMessage = ErrorMessage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Log)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Log.subclass:
            return Log.subclass(*args_, **kwargs_)
        else:
            return Log(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LogText(self): return self.LogText
    def set_LogText(self, LogText): self.LogText = LogText
    def get_ErrorMessage(self): return self.ErrorMessage
    def set_ErrorMessage(self, ErrorMessage): self.ErrorMessage = ErrorMessage
    def get_success(self): return self.success
    def set_success(self, success): self.success = success
    def hasContent_(self):
        if (
            self.LogText is not None or
            self.ErrorMessage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Log', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Log')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Log', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Log'):
        if self.success is not None and 'success' not in already_processed:
            already_processed.add('success')
            outfile.write(' success="%s"' % self.gds_format_boolean(self.success, input_name='success'))
    def exportChildren(self, outfile, level, namespace_='', name_='Log', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LogText is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLogText>%s</%sLogText>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.LogText), input_name='LogText')), namespace_, eol_))
        if self.ErrorMessage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sErrorMessage>%s</%sErrorMessage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ErrorMessage), input_name='ErrorMessage')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('success', node)
        if value is not None and 'success' not in already_processed:
            already_processed.add('success')
            if value in ('true', '1'):
                self.success = True
            elif value in ('false', '0'):
                self.success = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LogText':
            LogText_ = child_.text
            LogText_ = self.gds_validate_string(LogText_, node, 'LogText')
            self.LogText = LogText_
        elif nodeName_ == 'ErrorMessage':
            ErrorMessage_ = child_.text
            ErrorMessage_ = self.gds_validate_string(ErrorMessage_, node, 'ErrorMessage')
            self.ErrorMessage = ErrorMessage_
# end class Log


class TrainingDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Alphabet=None, SequenceLength=None, SequenceData=None, SeqMatrix=None):
        self.original_tagname_ = None
        self.Alphabet = Alphabet
        self.SequenceLength = SequenceLength
        self.SequenceData = SequenceData
        self.SeqMatrix = SeqMatrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrainingDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrainingDataType.subclass:
            return TrainingDataType.subclass(*args_, **kwargs_)
        else:
            return TrainingDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Alphabet(self): return self.Alphabet
    def set_Alphabet(self, Alphabet): self.Alphabet = Alphabet
    def get_SequenceLength(self): return self.SequenceLength
    def set_SequenceLength(self, SequenceLength): self.SequenceLength = SequenceLength
    def get_SequenceData(self): return self.SequenceData
    def set_SequenceData(self, SequenceData): self.SequenceData = SequenceData
    def get_SeqMatrix(self): return self.SeqMatrix
    def set_SeqMatrix(self, SeqMatrix): self.SeqMatrix = SeqMatrix
    def hasContent_(self):
        if (
            self.Alphabet is not None or
            self.SequenceLength is not None or
            self.SequenceData is not None or
            self.SeqMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TrainingDataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrainingDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TrainingDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TrainingDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TrainingDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Alphabet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAlphabet>%s</%sAlphabet>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Alphabet), input_name='Alphabet')), namespace_, eol_))
        if self.SequenceLength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSequenceLength>%s</%sSequenceLength>%s' % (namespace_, self.gds_format_integer(self.SequenceLength, input_name='SequenceLength'), namespace_, eol_))
        if self.SequenceData is not None:
            self.SequenceData.export(outfile, level, namespace_, name_='SequenceData', pretty_print=pretty_print)
        if self.SeqMatrix is not None:
            self.SeqMatrix.export(outfile, level, namespace_, name_='SeqMatrix', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Alphabet':
            Alphabet_ = child_.text
            Alphabet_ = self.gds_validate_string(Alphabet_, node, 'Alphabet')
            self.Alphabet = Alphabet_
        elif nodeName_ == 'SequenceLength':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SequenceLength')
            self.SequenceLength = ival_
        elif nodeName_ == 'SequenceData':
            obj_ = SequenceDataType.factory()
            obj_.build(child_)
            self.SequenceData = obj_
            obj_.original_tagname_ = 'SequenceData'
        elif nodeName_ == 'SeqMatrix':
            obj_ = SeqMatrix.factory()
            obj_.build(child_)
            self.SeqMatrix = obj_
            obj_.original_tagname_ = 'SeqMatrix'
# end class TrainingDataType


class SequenceDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataPoint=None):
        self.original_tagname_ = None
        if DataPoint is None:
            self.DataPoint = []
        else:
            self.DataPoint = DataPoint
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequenceDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequenceDataType.subclass:
            return SequenceDataType.subclass(*args_, **kwargs_)
        else:
            return SequenceDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataPoint(self): return self.DataPoint
    def set_DataPoint(self, DataPoint): self.DataPoint = DataPoint
    def add_DataPoint(self, value): self.DataPoint.append(value)
    def insert_DataPoint_at(self, index, value): self.DataPoint.insert(index, value)
    def replace_DataPoint_at(self, index, value): self.DataPoint[index] = value
    def hasContent_(self):
        if (
            self.DataPoint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SequenceDataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequenceDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SequenceDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequenceDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SequenceDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataPoint_ in self.DataPoint:
            DataPoint_.export(outfile, level, namespace_, name_='DataPoint', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataPoint':
            obj_ = DataPointType.factory()
            obj_.build(child_)
            self.DataPoint.append(obj_)
            obj_.original_tagname_ = 'DataPoint'
# end class SequenceDataType


class DataPointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Sequence=None, Threshold=None, Measured=None):
        self.original_tagname_ = None
        self.Sequence = Sequence
        self.Threshold = Threshold
        self.Measured = Measured
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataPointType.subclass:
            return DataPointType.subclass(*args_, **kwargs_)
        else:
            return DataPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Sequence(self): return self.Sequence
    def set_Sequence(self, Sequence): self.Sequence = Sequence
    def get_Threshold(self): return self.Threshold
    def set_Threshold(self, Threshold): self.Threshold = Threshold
    def get_Measured(self): return self.Measured
    def set_Measured(self, Measured): self.Measured = Measured
    def hasContent_(self):
        if (
            self.Sequence is not None or
            self.Threshold is not None or
            self.Measured is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataPointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DataPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataPointType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSequence>%s</%sSequence>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Sequence), input_name='Sequence')), namespace_, eol_))
        if self.Threshold is not None:
            self.Threshold.export(outfile, level, namespace_, name_='Threshold', pretty_print=pretty_print)
        if self.Measured is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMeasured>%s</%sMeasured>%s' % (namespace_, self.gds_format_double(self.Measured, input_name='Measured'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Sequence':
            Sequence_ = child_.text
            Sequence_ = self.gds_validate_string(Sequence_, node, 'Sequence')
            self.Sequence = Sequence_
        elif nodeName_ == 'Threshold':
            obj_ = ThresholdType.factory()
            obj_.build(child_)
            self.Threshold = obj_
            obj_.original_tagname_ = 'Threshold'
        elif nodeName_ == 'Measured':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Measured')
            self.Measured = fval_
# end class DataPointType


class ThresholdType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Greater=None, Lesser=None):
        self.original_tagname_ = None
        self.Greater = Greater
        self.Lesser = Lesser
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThresholdType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThresholdType.subclass:
            return ThresholdType.subclass(*args_, **kwargs_)
        else:
            return ThresholdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Greater(self): return self.Greater
    def set_Greater(self, Greater): self.Greater = Greater
    def get_Lesser(self): return self.Lesser
    def set_Lesser(self, Lesser): self.Lesser = Lesser
    def hasContent_(self):
        if (
            self.Greater is not None or
            self.Lesser is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ThresholdType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThresholdType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ThresholdType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ThresholdType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ThresholdType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Greater is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGreater>%s</%sGreater>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Greater), input_name='Greater')), namespace_, eol_))
        if self.Lesser is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLesser>%s</%sLesser>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Lesser), input_name='Lesser')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Greater':
            Greater_ = child_.text
            Greater_ = self.gds_validate_string(Greater_, node, 'Greater')
            self.Greater = Greater_
        elif nodeName_ == 'Lesser':
            Lesser_ = child_.text
            Lesser_ = self.gds_validate_string(Lesser_, node, 'Lesser')
            self.Lesser = Lesser_
# end class ThresholdType


class Greater(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Greater)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Greater.subclass:
            return Greater.subclass(*args_, **kwargs_)
        else:
            return Greater(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Greater', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Greater')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Greater', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Greater'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Greater', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Greater


class Lesser(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Lesser)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Lesser.subclass:
            return Lesser.subclass(*args_, **kwargs_)
        else:
            return Lesser(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Lesser', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Lesser')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Lesser', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Lesser'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Lesser', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Lesser


class MatrixCalculationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UseExternalMatrix=None, SMMMatrix=None):
        self.original_tagname_ = None
        self.UseExternalMatrix = UseExternalMatrix
        self.SMMMatrix = SMMMatrix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatrixCalculationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatrixCalculationType.subclass:
            return MatrixCalculationType.subclass(*args_, **kwargs_)
        else:
            return MatrixCalculationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UseExternalMatrix(self): return self.UseExternalMatrix
    def set_UseExternalMatrix(self, UseExternalMatrix): self.UseExternalMatrix = UseExternalMatrix
    def get_SMMMatrix(self): return self.SMMMatrix
    def set_SMMMatrix(self, SMMMatrix): self.SMMMatrix = SMMMatrix
    def hasContent_(self):
        if (
            self.UseExternalMatrix is not None or
            self.SMMMatrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatrixCalculationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatrixCalculationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatrixCalculationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatrixCalculationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MatrixCalculationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UseExternalMatrix is not None:
            self.UseExternalMatrix.export(outfile, level, namespace_, name_='UseExternalMatrix', pretty_print=pretty_print)
        if self.SMMMatrix is not None:
            self.SMMMatrix.export(outfile, level, namespace_, name_='SMMMatrix', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UseExternalMatrix':
            obj_ = UseExternalMatrixType.factory()
            obj_.build(child_)
            self.UseExternalMatrix = obj_
            obj_.original_tagname_ = 'UseExternalMatrix'
        elif nodeName_ == 'SMMMatrix':
            obj_ = SMMMatrixType.factory()
            obj_.build(child_)
            self.SMMMatrix = obj_
            obj_.original_tagname_ = 'SMMMatrix'
# end class MatrixCalculationType


class UseExternalMatrixType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdjustToSequenceData=None, AdjustOffsetToSequenceData=None):
        self.original_tagname_ = None
        self.AdjustToSequenceData = AdjustToSequenceData
        self.AdjustOffsetToSequenceData = AdjustOffsetToSequenceData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UseExternalMatrixType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UseExternalMatrixType.subclass:
            return UseExternalMatrixType.subclass(*args_, **kwargs_)
        else:
            return UseExternalMatrixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdjustToSequenceData(self): return self.AdjustToSequenceData
    def set_AdjustToSequenceData(self, AdjustToSequenceData): self.AdjustToSequenceData = AdjustToSequenceData
    def get_AdjustOffsetToSequenceData(self): return self.AdjustOffsetToSequenceData
    def set_AdjustOffsetToSequenceData(self, AdjustOffsetToSequenceData): self.AdjustOffsetToSequenceData = AdjustOffsetToSequenceData
    def hasContent_(self):
        if (
            self.AdjustToSequenceData is not None or
            self.AdjustOffsetToSequenceData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UseExternalMatrixType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UseExternalMatrixType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UseExternalMatrixType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UseExternalMatrixType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UseExternalMatrixType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AdjustToSequenceData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdjustToSequenceData>%s</%sAdjustToSequenceData>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AdjustToSequenceData), input_name='AdjustToSequenceData')), namespace_, eol_))
        if self.AdjustOffsetToSequenceData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdjustOffsetToSequenceData>%s</%sAdjustOffsetToSequenceData>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.AdjustOffsetToSequenceData), input_name='AdjustOffsetToSequenceData')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdjustToSequenceData':
            AdjustToSequenceData_ = child_.text
            AdjustToSequenceData_ = self.gds_validate_string(AdjustToSequenceData_, node, 'AdjustToSequenceData')
            self.AdjustToSequenceData = AdjustToSequenceData_
        elif nodeName_ == 'AdjustOffsetToSequenceData':
            AdjustOffsetToSequenceData_ = child_.text
            AdjustOffsetToSequenceData_ = self.gds_validate_string(AdjustOffsetToSequenceData_, node, 'AdjustOffsetToSequenceData')
            self.AdjustOffsetToSequenceData = AdjustOffsetToSequenceData_
# end class UseExternalMatrixType


class AdjustToSequenceData(GeneratedsSuper):
    """Performs a linear regression to adjust the External Matrix to the
    Sequence data. Use this if experimental sources for SequenceData
    and ExternalMatrix could be explained by a linear transformation"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustToSequenceData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustToSequenceData.subclass:
            return AdjustToSequenceData.subclass(*args_, **kwargs_)
        else:
            return AdjustToSequenceData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustToSequenceData', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustToSequenceData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustToSequenceData', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustToSequenceData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustToSequenceData', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AdjustToSequenceData


class AdjustOffsetToSequenceData(GeneratedsSuper):
    """Adjusts the Offset of the ExternalMatrix to optimally reproduce
    sequence data. Use this if experimental differences between
    ExternalMatrix and SequenceData could result in a constant
    absolute difference"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdjustOffsetToSequenceData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdjustOffsetToSequenceData.subclass:
            return AdjustOffsetToSequenceData.subclass(*args_, **kwargs_)
        else:
            return AdjustOffsetToSequenceData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdjustOffsetToSequenceData', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustOffsetToSequenceData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdjustOffsetToSequenceData', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdjustOffsetToSequenceData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AdjustOffsetToSequenceData', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AdjustOffsetToSequenceData


class SMMMatrixType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LambdaGrouping=None, SMMParameters=None):
        self.original_tagname_ = None
        self.LambdaGrouping = LambdaGrouping
        self.SMMParameters = SMMParameters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SMMMatrixType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SMMMatrixType.subclass:
            return SMMMatrixType.subclass(*args_, **kwargs_)
        else:
            return SMMMatrixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LambdaGrouping(self): return self.LambdaGrouping
    def set_LambdaGrouping(self, LambdaGrouping): self.LambdaGrouping = LambdaGrouping
    def get_SMMParameters(self): return self.SMMParameters
    def set_SMMParameters(self, SMMParameters): self.SMMParameters = SMMParameters
    def hasContent_(self):
        if (
            self.LambdaGrouping is not None or
            self.SMMParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SMMMatrixType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SMMMatrixType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SMMMatrixType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SMMMatrixType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SMMMatrixType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LambdaGrouping is not None:
            self.LambdaGrouping.export(outfile, level, namespace_, name_='LambdaGrouping', pretty_print=pretty_print)
        if self.SMMParameters is not None:
            self.SMMParameters.export(outfile, level, namespace_, name_='SMMParameters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LambdaGrouping':
            obj_ = LambdaGroupingType.factory()
            obj_.build(child_)
            self.LambdaGrouping = obj_
            obj_.original_tagname_ = 'LambdaGrouping'
        elif nodeName_ == 'SMMParameters':
            obj_ = SMMParameters.factory()
            obj_.build(child_)
            self.SMMParameters = obj_
            obj_.original_tagname_ = 'SMMParameters'
# end class SMMMatrixType


class LambdaGroupingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Individual=None, Position=None, One=None):
        self.original_tagname_ = None
        self.Individual = Individual
        self.Position = Position
        self.One = One
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LambdaGroupingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LambdaGroupingType.subclass:
            return LambdaGroupingType.subclass(*args_, **kwargs_)
        else:
            return LambdaGroupingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Individual(self): return self.Individual
    def set_Individual(self, Individual): self.Individual = Individual
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_One(self): return self.One
    def set_One(self, One): self.One = One
    def hasContent_(self):
        if (
            self.Individual is not None or
            self.Position is not None or
            self.One is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LambdaGroupingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LambdaGroupingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LambdaGroupingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LambdaGroupingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LambdaGroupingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Individual is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndividual>%s</%sIndividual>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Individual), input_name='Individual')), namespace_, eol_))
        if self.Position is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPosition>%s</%sPosition>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Position), input_name='Position')), namespace_, eol_))
        if self.One is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOne>%s</%sOne>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.One), input_name='One')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Individual':
            Individual_ = child_.text
            Individual_ = self.gds_validate_string(Individual_, node, 'Individual')
            self.Individual = Individual_
        elif nodeName_ == 'Position':
            Position_ = child_.text
            Position_ = self.gds_validate_string(Position_, node, 'Position')
            self.Position = Position_
        elif nodeName_ == 'One':
            One_ = child_.text
            One_ = self.gds_validate_string(One_, node, 'One')
            self.One = One_
# end class LambdaGroupingType


class Individual(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Individual)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Individual.subclass:
            return Individual.subclass(*args_, **kwargs_)
        else:
            return Individual(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Individual', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Individual')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Individual', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Individual'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Individual', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Individual


class Position(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Position)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Position.subclass:
            return Position.subclass(*args_, **kwargs_)
        else:
            return Position(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Position', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Position')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Position', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Position'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Position', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Position


class One(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, One)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if One.subclass:
            return One.subclass(*args_, **kwargs_)
        else:
            return One(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='One', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='One')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='One', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='One'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='One', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class One


class PairCalculationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IndividualLambdas=None, PairCoefCriteria=None, SMMParameters=None):
        self.original_tagname_ = None
        self.IndividualLambdas = IndividualLambdas
        self.PairCoefCriteria = PairCoefCriteria
        self.SMMParameters = SMMParameters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PairCalculationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PairCalculationType.subclass:
            return PairCalculationType.subclass(*args_, **kwargs_)
        else:
            return PairCalculationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IndividualLambdas(self): return self.IndividualLambdas
    def set_IndividualLambdas(self, IndividualLambdas): self.IndividualLambdas = IndividualLambdas
    def get_PairCoefCriteria(self): return self.PairCoefCriteria
    def set_PairCoefCriteria(self, PairCoefCriteria): self.PairCoefCriteria = PairCoefCriteria
    def get_SMMParameters(self): return self.SMMParameters
    def set_SMMParameters(self, SMMParameters): self.SMMParameters = SMMParameters
    def hasContent_(self):
        if (
            self.IndividualLambdas is not None or
            self.PairCoefCriteria is not None or
            self.SMMParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PairCalculationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PairCalculationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PairCalculationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PairCalculationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PairCalculationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IndividualLambdas is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndividualLambdas>%s</%sIndividualLambdas>%s' % (namespace_, self.gds_format_boolean(self.IndividualLambdas, input_name='IndividualLambdas'), namespace_, eol_))
        if self.PairCoefCriteria is not None:
            self.PairCoefCriteria.export(outfile, level, namespace_, name_='PairCoefCriteria', pretty_print=pretty_print)
        if self.SMMParameters is not None:
            self.SMMParameters.export(outfile, level, namespace_, name_='SMMParameters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IndividualLambdas':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IndividualLambdas')
            self.IndividualLambdas = ival_
        elif nodeName_ == 'PairCoefCriteria':
            obj_ = PairCoefCriteriaType.factory()
            obj_.build(child_)
            self.PairCoefCriteria = obj_
            obj_.original_tagname_ = 'PairCoefCriteria'
        elif nodeName_ == 'SMMParameters':
            obj_ = SMMParameters.factory()
            obj_.build(child_)
            self.SMMParameters = obj_
            obj_.original_tagname_ = 'SMMParameters'
# end class PairCalculationType


class PairCoefCriteriaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MinCount=None, MaxDisagrement=None):
        self.original_tagname_ = None
        self.MinCount = MinCount
        self.validate_MinCountType(self.MinCount)
        self.MaxDisagrement = MaxDisagrement
        self.validate_MaxDisagrementType(self.MaxDisagrement)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PairCoefCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PairCoefCriteriaType.subclass:
            return PairCoefCriteriaType.subclass(*args_, **kwargs_)
        else:
            return PairCoefCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MinCount(self): return self.MinCount
    def set_MinCount(self, MinCount): self.MinCount = MinCount
    def get_MaxDisagrement(self): return self.MaxDisagrement
    def set_MaxDisagrement(self, MaxDisagrement): self.MaxDisagrement = MaxDisagrement
    def validate_MinCountType(self, value):
        # Validate type MinCountType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on MinCountType' % {"value" : value} )
    def validate_MaxDisagrementType(self, value):
        # Validate type MaxDisagrementType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on MaxDisagrementType' % {"value" : value} )
            if value > 0.5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MaxDisagrementType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.MinCount is not None or
            self.MaxDisagrement is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PairCoefCriteriaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PairCoefCriteriaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PairCoefCriteriaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PairCoefCriteriaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PairCoefCriteriaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MinCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinCount>%s</%sMinCount>%s' % (namespace_, self.gds_format_integer(self.MinCount, input_name='MinCount'), namespace_, eol_))
        if self.MaxDisagrement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxDisagrement>%s</%sMaxDisagrement>%s' % (namespace_, self.gds_format_double(self.MaxDisagrement, input_name='MaxDisagrement'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MinCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MinCount')
            self.MinCount = ival_
            # validate type MinCountType
            self.validate_MinCountType(self.MinCount)
        elif nodeName_ == 'MaxDisagrement':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MaxDisagrement')
            self.MaxDisagrement = fval_
            # validate type MaxDisagrementType
            self.validate_MaxDisagrementType(self.MaxDisagrement)
# end class PairCoefCriteriaType


class RepeatsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Bagging=None, CrossValidation=None):
        self.original_tagname_ = None
        self.Bagging = Bagging
        self.validate_BaggingType(self.Bagging)
        self.CrossValidation = CrossValidation
        self.validate_CrossValidationType(self.CrossValidation)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RepeatsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RepeatsType.subclass:
            return RepeatsType.subclass(*args_, **kwargs_)
        else:
            return RepeatsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Bagging(self): return self.Bagging
    def set_Bagging(self, Bagging): self.Bagging = Bagging
    def get_CrossValidation(self): return self.CrossValidation
    def set_CrossValidation(self, CrossValidation): self.CrossValidation = CrossValidation
    def validate_BaggingType(self, value):
        # Validate type BaggingType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on BaggingType' % {"value" : value} )
    def validate_CrossValidationType(self, value):
        # Validate type CrossValidationType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CrossValidationType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Bagging is not None or
            self.CrossValidation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RepeatsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RepeatsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RepeatsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RepeatsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RepeatsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Bagging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBagging>%s</%sBagging>%s' % (namespace_, self.gds_format_integer(self.Bagging, input_name='Bagging'), namespace_, eol_))
        if self.CrossValidation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCrossValidation>%s</%sCrossValidation>%s' % (namespace_, self.gds_format_integer(self.CrossValidation, input_name='CrossValidation'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Bagging':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Bagging')
            self.Bagging = ival_
            # validate type BaggingType
            self.validate_BaggingType(self.Bagging)
        elif nodeName_ == 'CrossValidation':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'CrossValidation')
            self.CrossValidation = ival_
            # validate type CrossValidationType
            self.validate_CrossValidationType(self.CrossValidation)
# end class RepeatsType


class LambdaRangeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Min=None, Start=None, Max=None):
        self.original_tagname_ = None
        self.Min = Min
        self.validate_MinType(self.Min)
        self.Start = Start
        self.validate_StartType(self.Start)
        self.Max = Max
        self.validate_MaxType(self.Max)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LambdaRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LambdaRangeType.subclass:
            return LambdaRangeType.subclass(*args_, **kwargs_)
        else:
            return LambdaRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Min(self): return self.Min
    def set_Min(self, Min): self.Min = Min
    def get_Start(self): return self.Start
    def set_Start(self, Start): self.Start = Start
    def get_Max(self): return self.Max
    def set_Max(self, Max): self.Max = Max
    def validate_MinType(self, value):
        # Validate type MinType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on MinType' % {"value" : value} )
    def validate_StartType(self, value):
        # Validate type StartType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on StartType' % {"value" : value} )
    def validate_MaxType(self, value):
        # Validate type MaxType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on MaxType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Min is not None or
            self.Start is not None or
            self.Max is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LambdaRangeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LambdaRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LambdaRangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LambdaRangeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LambdaRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Min is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMin>%s</%sMin>%s' % (namespace_, self.gds_format_double(self.Min, input_name='Min'), namespace_, eol_))
        if self.Start is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStart>%s</%sStart>%s' % (namespace_, self.gds_format_double(self.Start, input_name='Start'), namespace_, eol_))
        if self.Max is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMax>%s</%sMax>%s' % (namespace_, self.gds_format_double(self.Max, input_name='Max'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Min':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Min')
            self.Min = fval_
            # validate type MinType
            self.validate_MinType(self.Min)
        elif nodeName_ == 'Start':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Start')
            self.Start = fval_
            # validate type StartType
            self.validate_StartType(self.Start)
        elif nodeName_ == 'Max':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Max')
            self.Max = fval_
            # validate type MaxType
            self.validate_MaxType(self.Max)
# end class LambdaRangeType


class SeqPairType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PairCoef=None):
        self.original_tagname_ = None
        if PairCoef is None:
            self.PairCoef = []
        else:
            self.PairCoef = PairCoef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SeqPairType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SeqPairType.subclass:
            return SeqPairType.subclass(*args_, **kwargs_)
        else:
            return SeqPairType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PairCoef(self): return self.PairCoef
    def set_PairCoef(self, PairCoef): self.PairCoef = PairCoef
    def add_PairCoef(self, value): self.PairCoef.append(value)
    def insert_PairCoef_at(self, index, value): self.PairCoef.insert(index, value)
    def replace_PairCoef_at(self, index, value): self.PairCoef[index] = value
    def hasContent_(self):
        if (
            self.PairCoef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SeqPairType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SeqPairType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SeqPairType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SeqPairType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SeqPairType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PairCoef_ in self.PairCoef:
            PairCoef_.export(outfile, level, namespace_, name_='PairCoef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PairCoef':
            obj_ = PairCoefType.factory()
            obj_.build(child_)
            self.PairCoef.append(obj_)
            obj_.original_tagname_ = 'PairCoef'
# end class SeqPairType


class PairCoefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Letter1=None, Position1=None, Letter2=None, Position2=None, Value=None):
        self.original_tagname_ = None
        self.Letter1 = Letter1
        self.validate_Letter1Type(self.Letter1)
        self.Position1 = Position1
        self.validate_Position1Type(self.Position1)
        self.Letter2 = Letter2
        self.validate_Letter2Type(self.Letter2)
        self.Position2 = Position2
        self.validate_Position2Type(self.Position2)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PairCoefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PairCoefType.subclass:
            return PairCoefType.subclass(*args_, **kwargs_)
        else:
            return PairCoefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Letter1(self): return self.Letter1
    def set_Letter1(self, Letter1): self.Letter1 = Letter1
    def get_Position1(self): return self.Position1
    def set_Position1(self, Position1): self.Position1 = Position1
    def get_Letter2(self): return self.Letter2
    def set_Letter2(self, Letter2): self.Letter2 = Letter2
    def get_Position2(self): return self.Position2
    def set_Position2(self, Position2): self.Position2 = Position2
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_Letter1Type(self, value):
        # Validate type Letter1Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on Letter1Type' % {"value" : value.encode("utf-8")} )
    def validate_Position1Type(self, value):
        # Validate type Position1Type, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Position1Type' % {"value" : value} )
    def validate_Letter2Type(self, value):
        # Validate type Letter2Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on Letter2Type' % {"value" : value.encode("utf-8")} )
    def validate_Position2Type(self, value):
        # Validate type Position2Type, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Position2Type' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Letter1 is not None or
            self.Position1 is not None or
            self.Letter2 is not None or
            self.Position2 is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PairCoefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PairCoefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PairCoefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PairCoefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PairCoefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Letter1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLetter1>%s</%sLetter1>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Letter1), input_name='Letter1')), namespace_, eol_))
        if self.Position1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPosition1>%s</%sPosition1>%s' % (namespace_, self.gds_format_integer(self.Position1, input_name='Position1'), namespace_, eol_))
        if self.Letter2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLetter2>%s</%sLetter2>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Letter2), input_name='Letter2')), namespace_, eol_))
        if self.Position2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPosition2>%s</%sPosition2>%s' % (namespace_, self.gds_format_integer(self.Position2, input_name='Position2'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_double(self.Value, input_name='Value'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Letter1':
            Letter1_ = child_.text
            Letter1_ = self.gds_validate_string(Letter1_, node, 'Letter1')
            self.Letter1 = Letter1_
            # validate type Letter1Type
            self.validate_Letter1Type(self.Letter1)
        elif nodeName_ == 'Position1':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Position1')
            self.Position1 = ival_
            # validate type Position1Type
            self.validate_Position1Type(self.Position1)
        elif nodeName_ == 'Letter2':
            Letter2_ = child_.text
            Letter2_ = self.gds_validate_string(Letter2_, node, 'Letter2')
            self.Letter2 = Letter2_
            # validate type Letter2Type
            self.validate_Letter2Type(self.Letter2)
        elif nodeName_ == 'Position2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Position2')
            self.Position2 = ival_
            # validate type Position2Type
            self.validate_Position2Type(self.Position2)
        elif nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
# end class PairCoefType


class PredictType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Sequence=None):
        self.original_tagname_ = None
        self.Sequence = Sequence
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PredictType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PredictType.subclass:
            return PredictType.subclass(*args_, **kwargs_)
        else:
            return PredictType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Sequence(self): return self.Sequence
    def set_Sequence(self, Sequence): self.Sequence = Sequence
    def hasContent_(self):
        if (
            self.Sequence is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PredictType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PredictType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PredictType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PredictType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PredictType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSequence>%s</%sSequence>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Sequence), input_name='Sequence')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Sequence':
            Sequence_ = child_.text
            Sequence_ = self.gds_validate_string(Sequence_, node, 'Sequence')
            self.Sequence = Sequence_
# end class PredictType


class PredictType1(GeneratedsSuper):
    """Fragment length used to scan Sequence with."""
    subclass = None
    superclass = None
    def __init__(self, ScanLength=None, Sequence=None, Predictions=None):
        self.original_tagname_ = None
        self.ScanLength = _cast(int, ScanLength)
        self.Sequence = Sequence
        self.Predictions = Predictions
        self.validate_PredictionsType(self.Predictions)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PredictType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PredictType1.subclass:
            return PredictType1.subclass(*args_, **kwargs_)
        else:
            return PredictType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Sequence(self): return self.Sequence
    def set_Sequence(self, Sequence): self.Sequence = Sequence
    def get_Predictions(self): return self.Predictions
    def set_Predictions(self, Predictions): self.Predictions = Predictions
    def get_ScanLength(self): return self.ScanLength
    def set_ScanLength(self, ScanLength): self.ScanLength = ScanLength
    def validate_PredictionsType(self, value):
        # Validate type PredictionsType, a restriction on xs:double.
        pass
    def hasContent_(self):
        if (
            self.Sequence is not None or
            self.Predictions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PredictType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PredictType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PredictType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PredictType1'):
        if self.ScanLength is not None and 'ScanLength' not in already_processed:
            already_processed.add('ScanLength')
            outfile.write(' ScanLength="%s"' % self.gds_format_integer(self.ScanLength, input_name='ScanLength'))
    def exportChildren(self, outfile, level, namespace_='', name_='PredictType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSequence>%s</%sSequence>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Sequence), input_name='Sequence')), namespace_, eol_))
        if self.Predictions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPredictions>%s</%sPredictions>%s' % (namespace_, self.gds_format_double_list(self.Predictions, input_name='Predictions'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ScanLength', node)
        if value is not None and 'ScanLength' not in already_processed:
            already_processed.add('ScanLength')
            try:
                self.ScanLength = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ScanLength <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Sequence':
            Sequence_ = child_.text
            Sequence_ = self.gds_validate_string(Sequence_, node, 'Sequence')
            self.Sequence = Sequence_
        elif nodeName_ == 'Predictions':
            Predictions_ = child_.text
            Predictions_ = self.gds_validate_double_list(Predictions_, node, 'Predictions')
            self.Predictions = Predictions_
            # validate type PredictionsType
            self.validate_PredictionsType(self.Predictions)
# end class PredictType1


class MatCoefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Letter=None, Position=None, Value=None):
        self.original_tagname_ = None
        self.Letter = Letter
        self.validate_LetterType(self.Letter)
        self.Position = Position
        self.validate_PositionType(self.Position)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatCoefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatCoefType.subclass:
            return MatCoefType.subclass(*args_, **kwargs_)
        else:
            return MatCoefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Letter(self): return self.Letter
    def set_Letter(self, Letter): self.Letter = Letter
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_LetterType(self, value):
        # Validate type LetterType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on LetterType' % {"value" : value.encode("utf-8")} )
    def validate_PositionType(self, value):
        # Validate type PositionType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositionType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Letter is not None or
            self.Position is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MatCoefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MatCoefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MatCoefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MatCoefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MatCoefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Letter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLetter>%s</%sLetter>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.Letter), input_name='Letter')), namespace_, eol_))
        if self.Position is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPosition>%s</%sPosition>%s' % (namespace_, self.gds_format_integer(self.Position, input_name='Position'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_double(self.Value, input_name='Value'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Letter':
            Letter_ = child_.text
            Letter_ = self.gds_validate_string(Letter_, node, 'Letter')
            self.Letter = Letter_
            # validate type LetterType
            self.validate_LetterType(self.Letter)
        elif nodeName_ == 'Position':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Position')
            self.Position = ival_
            # validate type PositionType
            self.validate_PositionType(self.Position)
        elif nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
# end class MatCoefType


GDSClassesMapping = {
    'DataPoint': DataPointType,
    'LambdaGrouping': LambdaGroupingType,
    'LambdaRange': LambdaRangeType,
    'MatCoef': MatCoefType,
    'MatrixCalculation': MatrixCalculationType,
    'PairCalculation': PairCalculationType,
    'PairCoef': PairCoefType,
    'PairCoefCriteria': PairCoefCriteriaType,
    'Predict': PredictType1,
    'Repeats': RepeatsType,
    'SMMMatrix': SMMMatrixType,
    'SeqPair': SeqPairType,
    'SequenceData': SequenceDataType,
    'Threshold': ThresholdType,
    'TrainingData': TrainingDataType,
    'UseExternalMatrix': UseExternalMatrixType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SMMTrainInput'
        rootClass = SMMTrainInput
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SMMTrainInput'
        rootClass = SMMTrainInput
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SMMTrainInput'
        rootClass = SMMTrainInput
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SMMTrainInput'
        rootClass = SMMTrainInput
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from smm import *\n\n')
        sys.stdout.write('import smm as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AdjustOffsetToSequenceData",
    "AdjustToSequenceData",
    "DataPointType",
    "Greater",
    "Individual",
    "LambdaGroupingType",
    "LambdaRangeType",
    "Lesser",
    "Log",
    "MatCoefType",
    "MatrixCalculationType",
    "One",
    "PairCalculationType",
    "PairCoefCriteriaType",
    "PairCoefType",
    "Position",
    "PredictType",
    "PredictType1",
    "RepeatsType",
    "SMMMatrixType",
    "SMMParameters",
    "SMMPredictInput",
    "SMMPredictOutput",
    "SMMPredictor",
    "SMMTrainInput",
    "SMMTrainOutput",
    "SeqMatrix",
    "SeqPairType",
    "SequenceDataType",
    "ThresholdType",
    "TrainingDataType",
    "UseExternalMatrixType"
]
